# Vulnerability Data Architecture

## Single Source of Truth: Network Intelligence

Ragnar uses **Network Intelligence** as the authoritative source for all vulnerability data. This prevents data conflicts, sync issues, and confusion.

### Data Flow

```
┌─────────────────┐
│  Nmap Scanner   │ ← Scans hosts with vulners.nse
└────────┬────────┘
         │
         ▼
┌─────────────────────────────────────────────┐
│  nmap_vuln_scanner.py                       │
│  - Parses nmap output                       │
│  - Determines severity (critical/high/etc)  │
│  - Filters real vulnerabilities             │
└────────┬────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────┐
│  Network Intelligence (SINGLE SOURCE)       │
│  - Stores: active_vulnerabilities{}         │
│  - File: active_findings.json               │
│  - Auto-resolves after timeout              │
│  - Tracks per network_id                    │
└────────┬────────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────────┐
│  Web API (/api/vulnerabilities)             │
│  - Reads from Network Intelligence          │
│  - Checks current network + default         │
│  - Real-time data                           │
└─────────────────────────────────────────────┘
```

### Auto-Repopulation Behavior

**If vulnerabilities are deleted via web UI:**
1. They are removed from Network Intelligence
2. Active findings JSON is updated
3. **BUT** if the next vulnerability scan finds the same issues, they will be automatically re-added
4. This ensures the system reflects **current reality**, not historical state

**Why this is good:**
- System shows actual current vulnerabilities
- No stale/incorrect "clean" status
- Forces proper remediation (not just hiding the data)

### Storage Details

#### Primary Storage (AUTHORITATIVE)
- **In-memory**: `shared_data.network_intelligence.active_vulnerabilities`
  - Structure: `{network_id: {vuln_id: vuln_data}}`
  - Example: `{"default_network": {"vuln_abc123": {...}}}`

- **Persistent**: `data/intelligence/active_findings.json`
  - Saved on every change
  - Loaded on startup

#### Legacy Storage (DEPRECATED - To Be Removed)
- `data/output/vulnerabilities/vulnerability_summary.csv`
- `data/output/vulnerabilities/final_vulnerability_summary.csv`
- `data/netkb.csv` - "Nmap Vulnerabilities" column
- Individual scan result files (kept for forensics/audit only)

### Network ID Handling

Network Intelligence organizes findings by network ID:
- **WiFi networks**: Hash-based ID (e.g., `net_9c99ea17`)
- **No WiFi/Unknown**: Falls back to `default_network`

The web API checks **both** current network ID and `default_network` to ensure vulnerabilities are always visible, even when network ID changes.

### Web UI Operations

#### View Vulnerabilities
```javascript
GET /api/vulnerabilities
→ Returns findings from Network Intelligence
→ Includes network context
```

#### Delete/Reset Vulnerabilities
```javascript
POST /api/data/reset-vulnerabilities
→ Clears Network Intelligence active_vulnerabilities
→ Saves updated JSON
→ Note: Will repopulate if found in next scan
```

#### Dashboard Stats
```javascript
GET /api/dashboard/stats
→ Counts from Network Intelligence
→ Real-time vulnerability count
```

### Migration Plan

**Phase 1 (Current):** ✅
- Network Intelligence is primary source
- CSV files still updated for backward compatibility
- Scanner feeds to Network Intelligence first

**Phase 2 (Next):**
- Remove CSV update logic from scanner
- Update display.py to read from Network Intelligence
- Keep raw scan files for forensics only

**Phase 3 (Future):**
- Remove all CSV dependencies
- Pure Network Intelligence system
- Cleaner, faster, no sync issues

### Developer Notes

**When adding new vulnerability sources:**
1. Feed to `shared_data.network_intelligence.add_vulnerability()`
2. Let Network Intelligence handle storage/persistence
3. Do NOT create separate CSV/file storage

**When reading vulnerabilities:**
1. Use `shared_data.network_intelligence.get_active_findings_for_dashboard()`
2. Check network_id fallback logic
3. Do NOT read CSV files directly

**Network ID fallback:**
```python
# Web API checks both current network and default
network_id = get_current_network_id()
vulns = active_vulnerabilities.get(network_id, {})

# Fallback to default_network if empty
if not vulns and network_id != "default_network":
    vulns = active_vulnerabilities.get("default_network", {})
```

### Troubleshooting

**Problem**: Web UI shows 0 vulnerabilities but scans found some
**Solution**: Check network ID mismatch - scans may use "default_network" while UI queries WiFi-based ID

**Problem**: Deleted vulnerabilities reappear
**Expected**: This is by design - they're being found in current scans

**Problem**: Vulnerabilities from old network still showing
**Solution**: They may be stored under old network_id - check active_findings.json

### Files Modified

- `actions/nmap_vuln_scanner.py` - Scanner feeds to Network Intelligence
- `network_intelligence.py` - Added fallback logic for network_id
- `webapp_modern.py` - Reads from Network Intelligence, documents auto-repopulation
